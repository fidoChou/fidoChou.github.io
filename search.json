[{"title":"Redis 那些事","url":"http://jocolorful.com/2020/09/06/Redis那些事/","content":"<blockquote>\n<p>纸上得来终觉浅，绝知此事要躬行</p>\n</blockquote>\n<p>2008 年，一家意大利创业公司嫌弃 MySQL 的性能，所以就自己搞了套数据库：Redis。这个个人开发的数据库究竟有哪些特性吸引着开发者？我将一一研读探秘：</p>\n<h1 id=\"特性\"><a href=\"#特性\" class=\"headerlink\" title=\"特性\"></a>特性</h1><h2 id=\"存储结构\"><a href=\"#存储结构\" class=\"headerlink\" title=\"存储结构\"></a>存储结构</h2><p>Redis 的全称是 Remote Dictionary Server（远程字典服务器）</p>\n<p>Redis 的键值除了是字符串还可以是其他数据类型：</p>\n<ol>\n<li>字符串</li>\n<li>散列</li>\n<li>列表</li>\n<li>集合</li>\n<li>有序集合</li>\n</ol>\n<h2 id=\"内容存储与持久化\"><a href=\"#内容存储与持久化\" class=\"headerlink\" title=\"内容存储与持久化\"></a>内容存储与持久化</h2><p>所有的数据都存储在内存中，内存的读写速度快于硬盘，一秒内可读写超过十万个键值。</p>\n<h2 id=\"功能丰富\"><a href=\"#功能丰富\" class=\"headerlink\" title=\"功能丰富\"></a>功能丰富</h2><p>键值的 TTL 、单线程模型、可实现队列</p>\n<h2 id=\"简单稳定\"><a href=\"#简单稳定\" class=\"headerlink\" title=\"简单稳定\"></a>简单稳定</h2><h1 id=\"入门\"><a href=\"#入门\" class=\"headerlink\" title=\"入门\"></a>入门</h1><h2 id=\"字符串类型\"><a href=\"#字符串类型\" class=\"headerlink\" title=\"字符串类型\"></a>字符串类型</h2><p>字符串类型是 Redis 中最基本的类型，它能存储任何形式的字符串，包括二进制数据。是其他 4 种数据类型的基础，一个字符串类型键最大哦的容量是 512 MB。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">SET key value<br>GET key<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"散列类型\"><a href=\"#散列类型\" class=\"headerlink\" title=\"散列类型\"></a>散列类型</h2><p>散列即 hash，其存储了字段 field 和 字段值的映射，「但字段值只能是字符串」，不支持其他数据类型。所以散列类型不能嵌套其他数据类型。</p>\n<img src=\"/images/hash.png\"  width=\"500px\"/>\n\n<p>命名规范一般遵守：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">key: 对象类型:id<br>field: 属性<br>value: 字段值<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">HSET key field value<br>HGET key field<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"列表类型\"><a href=\"#列表类型\" class=\"headerlink\" title=\"列表类型\"></a>列表类型</h2><p>Redis 列表类型内部使用双向链表（double linked list）实现，越接近两端速度越快，常用操作是两列表两端添加元素，或者获取列表片段。列表类型适合用来记录日志或者网站新鲜事。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">LPUSH key value or RPUSH key value<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"集合类型\"><a href=\"#集合类型\" class=\"headerlink\" title=\"集合类型\"></a>集合类型</h2><p>集合：不保证顺序、唯一</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">SADD key member<br>SREM key member<br></code></pre></td></tr></table></figure>\n<h2 id=\"有序集合\"><a href=\"#有序集合\" class=\"headerlink\" title=\"有序集合\"></a>有序集合</h2><ol>\n<li>内部是通过散列表和跳跃表实现的，所以即使读取中间的数据速度也很快（O(log(N))）</li>\n<li>列表对于位置的调整不太方便，但有序集合可以（更改元素分数即可）</li>\n<li>有序集合更消耗内存</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">ZADD key score memeber<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"类型对比\"><a href=\"#类型对比\" class=\"headerlink\" title=\"类型对比\"></a>类型对比</h2><table>\n<thead>\n<tr>\n<th align=\"left\">数据类型</th>\n<th align=\"left\">使用场景</th>\n<th align=\"left\">备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">string</td>\n<td align=\"left\">用于存储普通数据，int，string等等类型的基本类型数据</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">hash</td>\n<td align=\"left\">通常用于存储数据对象类型</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">list</td>\n<td align=\"left\">用于存储一些有序列表</td>\n<td align=\"left\">双端操作较快，适用于日志、 可实现队列（其实我也没实践过，哭</td>\n</tr>\n<tr>\n<td align=\"left\">set</td>\n<td align=\"left\">无序集合</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">sort set</td>\n<td align=\"left\">有序集合</td>\n<td align=\"left\"></td>\n</tr>\n</tbody></table>\n<p>有些关于 Redis Key 命名的设计规范，我借鉴了 <a href=\"https://www.infoq.cn/article/lxpytc3KckJPi72E8L3P\" target=\"_blank\" rel=\"noopener\">Redis 开发设计规范及案例分析</a> 做了以下总结，并且在实际场景中有所运用</p>\n<ol>\n<li>可读性： 以业务名为前缀，用冒号分隔，可使用业务名：子业务名：id 的结构命名，子业务下多单词可再用下划线分隔。</li>\n<li>简洁性：这里需要控制 key 的长度，key 的占用内存不容忽视。</li>\n<li>不包含转义：不包含空格、换行、单双引号以及其他转义字符。</li>\n</ol>\n<h1 id=\"一些高级用法\"><a href=\"#一些高级用法\" class=\"headerlink\" title=\"一些高级用法\"></a>一些高级用法</h1><h2 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h2><p>事务是「一组命令」的集合：要么执行，要么都不执行。只有所有的命令都执行完成才能得到每个结果的返回值。</p>\n<h3 id=\"事务的错误：\"><a href=\"#事务的错误：\" class=\"headerlink\" title=\"事务的错误：\"></a>事务的错误：</h3><ol>\n<li>语法错误：只要有一个错误就会不会执行。</li>\n<li>运行错误：如果某条命令错误，那么其他命令会继续执行。（Redis 并没有事务回滚 rollback 的功能</li>\n</ol>\n<h3 id=\"WATCH\"><a href=\"#WATCH\" class=\"headerlink\" title=\"WATCH\"></a>WATCH</h3><p>防止竞态：在 GET 获得键值后不被其他客户端修改。直到函数完成后才允许其他客户端修改。</p>\n<p>来，请出事务家族的另外一位成员「WATCH」</p>\n<p>WATCH 命令可以监控一个或者多个键，一旦其中一个键被修改或删除之后的事务就不再执行。监控直到 EXEC 执行。</p>\n<h2 id=\"过期时间\"><a href=\"#过期时间\" class=\"headerlink\" title=\"过期时间\"></a>过期时间</h2><p>通过 EXPIRE 设置某个 key 的过期时间</p>\n<!-- ## 访问频次限制 -->\n","categories":[],"tags":["不知不会"]},{"title":"Hackathon","url":"http://jocolorful.com/2020/09/06/Hackathon/","content":"<p>令人快乐的事：这周 Hackthon 我们拿了 final！</p>\n<center><img src=\"/images/127A0435.JPG\" width=\"600px\" /></center>\n\n<p>今年的 Hackthon 的主题是「聚焦创作者」</p>\n<p>（我想金亚哥哥考试成绩一定很好，因为他押题很准，毕竟船长在海盗船里一直传递这个想法）</p>\n<p>我们的战队名字叫PPA（Power Point Athon）回头来看了眼群公告：里面的内容包括了 「联调沙盒」、「立项」、「PPT」、「数据摸底」、「设计文档」… 不知道其他团队的公告是什么样的，但从公告里看得出我们确实做了充分的准备。</p>\n<h1 id=\"Day-1\"><a href=\"#Day-1\" class=\"headerlink\" title=\"Day 1\"></a>Day 1</h1><p>主题「聚焦创作者」发送至各个海盗邮箱。脑暴开始，大家把自己的 idea 写进了 Google 文档。我想的 idea 是创作者成团和内容分发相关，以下👇</p>\n<p>来个鸡汤：一个人可以走很快，但一群人可以走很远。为什么普通的创作者死得快，因为他们没有专业的技能。<br>但是一个团队就不一样了，每个人只要发挥自己的特长就行。我们打造一个「成团榜单」即可，就像 Hackthon 吧。（PS，即便是快手、抖音应该也有专业的团队来运营这些号。但是，他们有专门的系统来帮助他们成团并且运营吗？我不知道。。。hhhh）</p>\n<h1 id=\"Day-2\"><a href=\"#Day-2\" class=\"headerlink\" title=\"Day 2\"></a>Day 2</h1><p>晚上「快闪课堂」idea 筛选。从晚 7 点 到 晚 9 点。各抒己见之后决定利用百度云的 SDK</p>\n<ol>\n<li>基于视频检索，提供视频素材检索能力</li>\n<li>搜索框可以搜索到视频，提供一个视频搜索产品方案</li>\n<li>视频素材热度趋势排行榜</li>\n</ol>\n<h1 id=\"Day-3\"><a href=\"#Day-3\" class=\"headerlink\" title=\"Day 3\"></a>Day 3</h1><p>基于 idea 产出产品原型，明确分工。同时还分析出了我们的成本其中包括人力成本、推广成本、技术成本（媒体分析 百度云 单价6元/小时、服务器、CDN、数据库…）</p>\n<ol>\n<li>PM: 老张、双男、张湃</li>\n<li>运营：程赛</li>\n<li>设计：静远</li>\n<li>前端：周颖、德镇</li>\n<li>后端：茗一、后斌</li>\n<li>数据分析：舒鸿</li>\n<li>演讲家：侯策</li>\n<li>整体进度：金亚</li>\n</ol>\n<p>金亚哥哥看上去像一个 CEO（只有傻子才等到周四才开始想）。前端利用已有的项目 xen 搭建了一个小页面。大家还脑暴了产品名字：积木计划！</p>\n<h1 id=\"Day-4\"><a href=\"#Day-4\" class=\"headerlink\" title=\"Day 4\"></a>Day 4</h1><p>比赛拉开序幕后，大家开始写码。其他组似乎还在脑暴 idea，我们组看起来格外的轻松。我甚至边写还边溜达，Hackthon 的伙食不错：各类小食，饮料，水果。写码不是件难事，难的是 iead 的产出和设计（静远老师相当给力）当然演讲是最重要的一环。侯老师和舒鸿也在认真准备 PPT。（舒鸿是耐看型的，侯老师眼光不错）</p>\n<h1 id=\"Day-5\"><a href=\"#Day-5\" class=\"headerlink\" title=\"Day 5\"></a>Day 5</h1><p>The last day。</p>\n<p>早上八点多我就到公司暗中观察，这些年轻小伙子们太理智了，居然没人通宵！</p>\n<p>xen 的 app 实在太多，构建非常耗时。导致交付前两小时有些凌乱。我抱着我的猪排饭紧盯着 zae 的构建，吃饭时甚至不敢讲话。当构建完成后，我和德镇的 Demo 终于能够串联起来，我俩终于松了口气。然后我就拎着不知道谁的滑板出去玩了。</p>\n<center><img src=\"/images/huaban\" width=\"300px\" /></center>\n\n<p>我也是没心没肺，回来时已经是带着受伤的猪蹄。德镇还在处理好物推荐的 bug，侯老师他们找了个小黑屋准备演讲。我拿着冰块敷着猪蹄 … 吃着鸡米花。我自嘲道，我这个样子怎么上台领奖呢？</p>\n<p>下午三点是作品 Battle Time。说实话，没有几个作品给我留下了深刻的印象，即便是获得人气奖的「摘星计划」</p>\n<p>今天公布第一名的时候，我看到积木计划愣了几秒，感觉有些陌生（我心里一直想的是 PPA 战队，后来反应过来，确实是我们嘛）。主持人说我们组看上去是比赛过程中最悠闲的一组，还拿着自己的手环到处交换颜色，确实也是如此 🤦‍♀️</p>\n<center><img src=\"/images/127A1071.JPG\" width=\"500px\" /></center>\n\n<center><img src=\"/images/money.jpg\" width=\"500px\" /></center>\n\n\n<center>同时周五也是我登船一周年的纪念日。</center>\n\n<p>我在 Qunar 也参加了很多的活动，什么趣味运动会、1024 视频活动、Code Review …每次想拿个奖都费了很大的力气。而这次大家都付出了努力，致敬每一位认真对待的参赛者！</p>\n<p>Hackthon 已经过去两天，当我回顾这次旅程时我的心情依旧感到快乐并且难以平静。</p>\n","categories":[],"tags":["生活"]},{"title":"🧗‍♀️当我爬山时，我在想什么？","url":"http://jocolorful.com/2020/08/29/climb/","content":"<p>作为一个户外的领队，我可以很自豪的说我爬过这些山： 东北灵，凤凰岭 妙峰山 阳台山（三山穿越）、百花山、玉渡山、五台（东台）、坡峰岭… …实在太多就不一一罗列。那当爬山时我在想些什么？</p>\n<p>一开始接触户外时，我就走了一个三峰（连续爬三座山，完事儿后还逛了个商场吃了个火锅）此时我发现我骨骼惊奇，开始有空就出门爬山。后来参加青青的次数太多觉得不划算，索性自己也当个领队好了。</p>\n<h1 id=\"初来乍到\"><a href=\"#初来乍到\" class=\"headerlink\" title=\"初来乍到\"></a>初来乍到</h1><p>其实作为一名合格的社畜，周末有时间爬山是非常难能可贵的。上一家公司加班尤为严重，所以刚开始接触爬山时，经过了一周的职场 PUA，在爬升的过程中我满脑子都是「我为什么就不能在家里睡个懒觉，非要跟这群不认识的人爬山？」、「这群人为什么走得这么快，我太弱了… …」、「这到底什么时候才是个头啊？」</p>\n<p>作为一个审慎的弱 🐔，在看见陡峭的岩石时会她会在心里暗暗盘算：我接下来应该这么走以便于好下脚；当手脚并用的爬过一段山路时，她会感到非常得意！当她一不小心摔了个屁股：害，糗大了！当她第一次拿到手台进行调频和其他人进行沟通时：哇，这个好神奇啊！香港电影的保安也用这个！</p>\n<h1 id=\"弱鸡进化时\"><a href=\"#弱鸡进化时\" class=\"headerlink\" title=\"弱鸡进化时\"></a>弱鸡进化时</h1><p>山爬多了，弱鸡不再是弱鸡。她俨然成了一只魔王小鸡… …山路崎岖、风景独秀已经不再能让魔王鸡感到振奋以及新奇。那是什么支撑着魔王鸡爬山呢？</p>\n<p>最简单的理由是习惯吧！当然完美地进行一次徒步或者攀登，弱鸡队员们对魔王鸡表示的感谢同样也鼓舞着她继续带队。</p>\n<p>一个人爬山和一群人爬山途中的想法会略有不同：</p>\n<p>今天恰好一个人爬了香八拉，在登好汉坡的时候我告诉自己：既然已经出来了，就不用过多地追求速度，而是应该享受爬山的过程。当我爬到快山顶回头望时，风景是真真地好。</p>\n<center><img src=\"/images/xiangbala.jpg\"  width=\"300px\" /></center>\n\n<p>如果我没有爬过这里的经验，我有勇气带队员来这里吗？我的答案是否定的，因为人生总是充满了意外。作为组织者，如果有任何意外我都必须负起一定的责任。</p>\n<p>出门前我带了两瓶速溶，作为一个咖啡因患者，喝咖啡是我的习惯。但是爬山的时候我真正需要的是矿泉水。所以更应该关注：「你需要什么，而不是你喜欢什么」</p>\n<p>有一条小道我走叉了，因为我顾着和群里聊天忘记看路了… 幸好及时修正了过来</p>\n<p>“如果小熊在，她肯定又要走一些奇奇怪怪的路。”</p>\n<p>“阿凯也曾经一个人走过这条路线”</p>\n<p>… …</p>\n<p>当我一个人在爬山时，我在想什么👆？爬完之后我感觉更加的笃定，心情也相应地平静下来。</p>\n<p>那一群人爬山时，我在想什么？</p>\n<p>（这个人怎么还不走？这个人体力太差了，应该多锻炼多锻炼；这个小孩子太皮了，管都管不住。这个队员会不喜欢我今天的表现吗？… …）</p>\n<p>一群人爬山时也有一群人的快乐，比如今年就认识了废物无限的元老成员，当个废物没有什么不好。一群人爬山不会给个人留太多的思考时间，我们会一起聊天、唱歌拍照，会做游戏会做一切令人快乐的事。也经常会遇到同行，我们会有共同的语言：Javascript！</p>\n<p>趁着心血来潮就先写到这里，我也不知道该写些什么了。当我爬山时，下一次我希望什么都不用想… …</p>\n","categories":[],"tags":["生活"]},{"title":"定时整理 - 夏日随想","url":"http://jocolorful.com/2020/08/06/夏日随想/","content":"<p>很浮躁，趁着没什么需求就随便记录点什么吧。觉得自己是一个充满了 bug 的人。<br>是不是该花点时间读书了？读书笔记很久没有写了。</p>\n<p>我发现我有很多想法，但是我会把这些想法删了又删，我其实好像还是很怕暴露自己的想法。</p>\n<p>我没有归纳总结的能力，就算是有我很难得到教训…</p>\n<p>我需要不断充实自己，因为    我想离开这座城市。</p>\n<p>在离开这里前我想去这些城市 👇</p>\n<table>\n<thead>\n<tr>\n<th>起点</th>\n<th>终点</th>\n<th>想去的地方</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>北京</td>\n<td>泰安</td>\n<td>泰山</td>\n</tr>\n<tr>\n<td></td>\n<td>秦皇岛</td>\n<td>阿那亚</td>\n</tr>\n<tr>\n<td></td>\n<td>山东</td>\n<td>长岛</td>\n</tr>\n<tr>\n<td></td>\n<td>吉林</td>\n<td>长白山</td>\n</tr>\n</tbody></table>\n<p>先摸 🐟 到这里吧，毕竟还是要学习，hhh… 如果我今天有其他的想法，晚上我会在记录一下。如果没有就 End     ～</p>\n","categories":[],"tags":["生活"]},{"title":"如何优雅地处理前端异常？","url":"http://jocolorful.com/2020/07/09/catch-error/","content":"<p>原文：<a href=\"https://zhuanlan.zhihu.com/p/51800345\" target=\"_blank\" rel=\"noopener\">如何优雅处理前端异常？</a></p>\n<h1 id=\"异常的种类\"><a href=\"#异常的种类\" class=\"headerlink\" title=\"异常的种类\"></a>异常的种类</h1><ol>\n<li>JS 语法错误、代码异常</li>\n<li>Ajax 请求异常</li>\n<li>静态资源加载异常</li>\n<li>Promise 异常</li>\n<li>iframe 异常</li>\n<li>跨域 Script error</li>\n<li>崩溃和卡顿</li>\n</ol>\n<p>对于第二点：Ajax 异常，我更偏好称之为 http 异常<br>对于第四点：Promise 异常，我更偏好称之为异步异常</p>\n<h1 id=\"异常的处理\"><a href=\"#异常的处理\" class=\"headerlink\" title=\"异常的处理\"></a>异常的处理</h1><p>针对以上异常的种类，我们来看一下怎么处理：</p>\n<h2 id=\"try-catch-的误区\"><a href=\"#try-catch-的误区\" class=\"headerlink\" title=\"try-catch  的误区\"></a>try-catch  的误区</h2><blockquote>\n<p>try-catch 只能捕获到同步的运行时错误，对语法和异步错误却无能为力</p>\n</blockquote>\n<h2 id=\"window-onerror-并不是万能的\"><a href=\"#window-onerror-并不是万能的\" class=\"headerlink\" title=\"window.onerror 并不是万能的\"></a>window.onerror 并不是万能的</h2><ol>\n<li>同步异常可捕获</li>\n<li>语法错误不能捕获</li>\n<li>异步异常可捕获</li>\n</ol>\n<blockquote>\n<p>onerror 最好写在所有 JS 脚本的前面，否则有可能捕获不到错误；onerror 无法捕获语法错误；</p>\n</blockquote>\n<h2 id=\"window-addEventListener\"><a href=\"#window-addEventListener\" class=\"headerlink\" title=\"window.addEventListener\"></a>window.addEventListener</h2><p>当静态资源加载失败会触发 error 事件。由于网络请求异常不会事件冒泡，因此必须在捕获阶段将其捕捉到才行，但是这种方式虽然可以捕捉到网络请求的异常，但是无法判断 HTTP 的状态是 404 还是其他比如 500 等等，所以还需要配合服务端日志才进行排查分析才可以。</p>\n<h2 id=\"Promise-Catch\"><a href=\"#Promise-Catch\" class=\"headerlink\" title=\"Promise Catch\"></a>Promise Catch</h2><p>promise 的 catch 可以非常容易地捕获异步的错误。</p>\n<p>没有 catch 的 Promise 中抛出的错误无法被 onError 或 try-catch捕获到。所以务必要写 catch 处理抛出异常。</p>\n<p>解决方案： 为了防止有漏掉的 Promise 异常，建议在全局增加一个对 unhandledrejection 的监听，用来全局监听Uncaught Promise Error。使用方式：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-built_in\">window</span>.addEventListener(<span class=\"hljs-string\">\"unhandledrejection\"</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">e</span>) </span>&#123;<br>  <span class=\"hljs-built_in\">console</span>.log(e)<br>&#125;)<br></code></pre></td></tr></table></figure>\n<p>那如果对 Promise 不进行 catch 呢:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-built_in\">window</span>.addEventListener(<span class=\"hljs-string\">\"unhandledrejection\"</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">e</span>)</span>&#123;<br>  e.preventDefault()<br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'捕获到异常：'</span>, e)<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span><br>&#125;)<br><br><span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> &#123;<br>  reject(<span class=\"hljs-string\">'jartto: promise error'</span>)<br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<p><font color=\"red\">如果去掉控制台的异常显示，需要加上：</font></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">event.preventDefault()<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"React-的异常处理\"><a href=\"#React-的异常处理\" class=\"headerlink\" title=\"React 的异常处理\"></a>React 的异常处理</h2><p>UI的某部分引起的 JS 错误不应该破坏整个程序，为了帮React的使用者解决这个问题，React 16介绍了一种关于错误边界</p>\n<p>注意： error boundaries并不会捕捉这些错误：</p>\n<ol>\n<li><p>事件处理器</p>\n</li>\n<li><p>异步代码</p>\n</li>\n<li><p>服务端的渲染代码</p>\n</li>\n<li><p>在error boundaries区域内的错误</p>\n</li>\n</ol>\n<h2 id=\"iframe-异常\"><a href=\"#iframe-异常\" class=\"headerlink\" title=\"iframe 异常\"></a>iframe 异常</h2><p>借助 window.onerror</p>\n<h2 id=\"script-异常\"><a href=\"#script-异常\" class=\"headerlink\" title=\"script 异常\"></a>script 异常</h2><h2 id=\"崩溃和卡顿\"><a href=\"#崩溃和卡顿\" class=\"headerlink\" title=\"崩溃和卡顿\"></a>崩溃和卡顿</h2><ol>\n<li>利用 window 对象的 「load」 和 「beforeunload」 事件实现了「网页崩溃」的监控</li>\n<li>使用 Service Worker 来实现网页崩溃的监控：<ol>\n<li>Service Worker 有自己独立的工作线程，与网页区分开，网页崩溃了，Service Worker 下不会崩溃；</li>\n<li>Service Worker 生命周期一般要比网页还要长，可以用来监控网页的状态；</li>\n<li>网页可以通过 navigator.serviceWorker.controller.postMessage API 向掌管自己的 SW发送消息</li>\n</ol>\n</li>\n</ol>\n<h1 id=\"错误上报\"><a href=\"#错误上报\" class=\"headerlink\" title=\"错误上报\"></a>错误上报</h1><ol>\n<li>利用 Ajax 请求上报</li>\n<li>动态创建 img 标签的形式</li>\n</ol>\n<p>上报时，设置采集率以减少服务器压力</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">Reporter.send = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">data</span>) </span>&#123;<br>  <span class=\"hljs-comment\">// 只采集 30%</span><br>  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">Math</span>.random() &lt; <span class=\"hljs-number\">0.3</span>) &#123;<br>    send(data)      <span class=\"hljs-comment\">// 上报错误信息</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>","categories":[],"tags":["不知不会"]},{"title":"工具集","url":"http://jocolorful.com/2020/07/08/工具集/","content":"<p><a href=\"https://mdnice.com/\" target=\"_blank\" rel=\"noopener\">微信公众号排版</a></p>\n<p><a href=\"https://carbon.now.sh/\" target=\"_blank\" rel=\"noopener\">🎨 代码界的美图秀秀</a></p>\n","categories":[],"tags":["整理"]},{"title":"GET 和 POST 的差异","url":"http://jocolorful.com/2020/07/07/2020-POST/","content":"<p>原文：<a href=\"https://segmentfault.com/a/1190000018129846\" target=\"_blank\" rel=\"noopener\">都9102年了，还问GET和POST的区别</a></p>\n<ol>\n<li><p>GET 和 POST 只是 HTTP 协议中两种请求方式，而 HTTP 协议是基于 TCP/IP 的应用层协议，无论 GET 还是 POST，用的都是同一个传输层协议，所以在传输层上，没有任何区别。</p>\n<ol>\n<li><p>当 GET 和 POST 「不携带参数」时，最大的区别是第一行方法名不同:<br>请求报文第一行</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">GET /uri HTTP/1.1 \\r\\n<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">POST /uri HTTP/1.1 \\r\\n<br></code></pre></td></tr></table></figure>\n</li>\n<li><p>当 GET 和 POST 「携带参数」时，安装约定 GET 方法的参数应该放在 URL 里，POST 方法的参数应该放在  body 中</p>\n<p>GET 简约版报文</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">GET /index.php?name=qiming.c&amp;age=22 HTTP/1.1<br>Host: localhost<br></code></pre></td></tr></table></figure>\n\n<p>POST 简约版报文</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">POST /index.php HTTP/1.1<br>Host: localhost<br>Content-Type: application/x-www-form-urlencoded<br>name=qiming.c&amp;age=22<br></code></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n<li><p>「浏览器」的 URL 有长度限制是出于「安全」和「性能」考虑，在解析长 URL 时需防止恶意构造长 URL 来进行攻击，和 HTTP 协议本身没有关系。</p>\n</li>\n</ol>\n","categories":[],"tags":["不知不会"]},{"title":"前端性能量化标准读后感","url":"http://jocolorful.com/2020/07/01/前端性能量化标准读后感/","content":"<p>祭出原 issue 👉 <a href=\"https://github.com/frontend9/fe9-library/issues/7\" target=\"_blank\" rel=\"noopener\">前端性能量化标准</a></p>\n<h1 id=\"它正在发生吗？\"><a href=\"#它正在发生吗？\" class=\"headerlink\" title=\"它正在发生吗？\"></a>它正在发生吗？</h1><p>FP：First paint 第一个像素绘制时间<br>FCP：First Content paint 首次内容绘制时间</p>\n<ol>\n<li><p>window.performance.getEntriesByType(‘paint’)</p>\n</li>\n<li><p>当然也可以使用 lighthouse，<br>这里我全局安装的 lighthouse</p>\n</li>\n</ol>\n<h1 id=\"它是否有用？\"><a href=\"#它是否有用？\" class=\"headerlink\" title=\"它是否有用？\"></a>它是否有用？</h1><p>FMP： First meaningful paint<br>hero element timing</p>\n<p>Lighthouse 使用的算法是：页面绘制布局「变化」最大的那次绘制（根据 页面高度/屏幕高度 调节权重）</p>\n<h1 id=\"它是否令人愉快的\"><a href=\"#它是否令人愉快的\" class=\"headerlink\" title=\"它是否令人愉快的\"></a>它是否令人愉快的</h1><p>Long tasks。</p>\n<p>JS 线程与 GUI 线程互斥。JS 如果在执行，那么渲染线程就会被阻塞。如果一个 LT 超过 50 ms ，就说明这个线程有问题。</p>\n<h1 id=\"它是否可用？\"><a href=\"#它是否可用？\" class=\"headerlink\" title=\"它是否可用？\"></a>它是否可用？</h1><p>TTI：Time to interactive（页面已经渲染并且可以响应用户交互）。不能响应用户的原因有：</p>\n<ol>\n<li>JS 的资源还未加载完。</li>\n<li>Long Task 阻塞了主线程</li>\n</ol>\n<h1 id=\"思考\"><a href=\"#思考\" class=\"headerlink\" title=\"思考\"></a>思考</h1><p>当然这片文章还提出了一些优化策略，优化过程应该是一个全链路的解决方案。</p>\n<p>关于测量标准记录这些，策略手段我想我的学习清单又是一篇长笔记！</p>\n","categories":[],"tags":["不知不会"]},{"title":"CSS 性能优化的 8 个技巧","url":"http://jocolorful.com/2020/06/19/CSS性能优化的8个技巧/","content":"<blockquote>\n<p>这周周会翼巧同学分享了「内联首屏关键CSS(Critical CSS)」我学习的热情又燃起来了！</p>\n</blockquote>\n<p>祭出原文👉 <a href=\"https://juejin.im/post/5ece2a1e6fb9a048021466b0?utm_source=gold_browser_extension\" target=\"_blank\" rel=\"noopener\">CSS性能优化的 8 个技巧</a></p>\n<p>翼巧同学使用的是第一种方式（但不是内联，是内嵌），反正我已经知道怎么做的了，来看看优缺点吧！</p>\n<h1 id=\"关键-CSS\"><a href=\"#关键-CSS\" class=\"headerlink\" title=\"关键 CSS\"></a>关键 CSS</h1><h2 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h2><ol>\n<li>内联 CSS 能够使浏览器开始页面渲染的时间提前</li>\n</ol>\n<h2 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h2><ol>\n<li><p>无法缓存 CSS</p>\n</li>\n<li><p>内嵌样式体积需要较小</p>\n</li>\n</ol>\n<h1 id=\"异步加载-CSS\"><a href=\"#异步加载-CSS\" class=\"headerlink\" title=\"异步加载 CSS\"></a>异步加载 CSS</h1><ol>\n<li>通过 script 标签异步创建 link 标签</li>\n<li><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">link</span> <span class=\"hljs-attr\">rel</span>=<span class=\"hljs-string\">\"preload\"</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">\"mystyles.css\"</span> <span class=\"hljs-attr\">as</span>=<span class=\"hljs-string\">\"style\"</span> <span class=\"hljs-attr\">onload</span>=<span class=\"hljs-string\">\"this.rel='stylesheet'\"</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h1 id=\"文件压缩\"><a href=\"#文件压缩\" class=\"headerlink\" title=\"文件压缩\"></a>文件压缩</h1><h1 id=\"去除无用-CSS\"><a href=\"#去除无用-CSS\" class=\"headerlink\" title=\"去除无用 CSS\"></a>去除无用 CSS</h1><ol>\n<li>保持简单，不要使用嵌套过多过于复杂的选择器</li>\n<li>通配符和属性选择器效率最低，需要匹配的元素最多，尽量避免使用</li>\n<li>不要使用类选择器和 ID 选择器修饰元素标签</li>\n<li>不要为了追求速度而放弃可读性与可维护性</li>\n</ol>\n<p>复习一遍： 为什么CSS选择器是从右向左匹配的</p>\n<blockquote>\n<p>CSS 中更多的选择器是不会匹配的，所以在考虑性能问题时，需要考虑的是如何在选择器「不匹配」时提升效率。从右向左匹配就是为了达成这一目的的，通过这一策略能够使得CSS选择器在不匹配的时候效率更高。这样想来，在匹配时多耗费一些性能也能够想的通了</p>\n</blockquote>\n<h1 id=\"减少使用昂贵的属性\"><a href=\"#减少使用昂贵的属性\" class=\"headerlink\" title=\"减少使用昂贵的属性\"></a>减少使用昂贵的属性</h1><h1 id=\"减少重排和避免重绘\"><a href=\"#减少重排和避免重绘\" class=\"headerlink\" title=\"减少重排和避免重绘\"></a>减少重排和避免重绘</h1><h1 id=\"不要使用-import\"><a href=\"#不要使用-import\" class=\"headerlink\" title=\"不要使用 @import\"></a>不要使用 @import</h1><p>使用@import引用的 CSS 文件只有在引用它的那个css文件被「下载、解析」之后，浏览器才会知道还有另外一个 CSS 需要下载，这时才去下载，然后下载后开始解析、构建render tree等一系列操作。这就导致浏览器无法并行下载所需的样式文件。</p>\n<p>直接导致的后果：</p>\n<p>当然是异步加载完的重绘</p>\n<p>That’s All !</p>\n<p>犹梦杰同学分享了一个高大上的分享，反正我是听不到太懂？ 我决定周末在家无聊的时候补一下。hiahiahia</p>\n","categories":[],"tags":["不知不会"]},{"title":"我的学习清单","url":"http://jocolorful.com/2020/06/19/ReadList/","content":"<h1 id=\"JavaScript\"><a href=\"#JavaScript\" class=\"headerlink\" title=\"JavaScript\"></a>JavaScript</h1><ul>\n<li><input disabled=\"\" type=\"checkbox\"> Mercury</li>\n</ul>\n<h1 id=\"CSS\"><a href=\"#CSS\" class=\"headerlink\" title=\"CSS\"></a>CSS</h1><ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> <a href=\"http://jocolorful.com/2020/05/25/%E6%88%91%E9%9C%80%E8%A6%81%E8%83%8C%E4%BC%9A%E7%9A%84%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/\">css加载会造成阻塞吗</a></li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> <a href=\"https://juejin.im/post/5c35953ce51d45523f04b6d2\" target=\"_blank\" rel=\"noopener\">不可思议的纯 CSS 滚动进度条效果</a></li>\n</ul>\n<h1 id=\"HTML\"><a href=\"#HTML\" class=\"headerlink\" title=\"HTML\"></a>HTML</h1><h1 id=\"工程能力\"><a href=\"#工程能力\" class=\"headerlink\" title=\"工程能力\"></a>工程能力</h1><ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> <a href=\"\">前端缓存最佳实践</a></li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> <a href=\"https://github.com/frontend9/fe9-library/issues/7\" target=\"_blank\" rel=\"noopener\">前端性能量化标准</a></li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> <a href=\"https://zhuanlan.zhihu.com/p/51800345\" target=\"_blank\" rel=\"noopener\">如何优雅处理前端异常？</a></li>\n</ul>\n<h1 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h1><ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> iTerm2 的总结</li>\n<li><input disabled=\"\" type=\"checkbox\"> sublime 配置</li>\n</ul>\n","categories":[],"tags":["整理"]},{"title":"天空之城","url":"http://jocolorful.com/2020/05/28/天空之城/","content":"<center>\n我是天空里的云\n\n<p>投影在你的城</p>\n<p>你是否看得见</p>\n<p>那阵细雨有我的泪</p>\n<p>我放任在天空飞</p>\n<p>随风飘舞任风吹</p>\n<p>你是否还在那座城里</p>\n<p>坚守着我的归期</p>\n<p>不曾后悔爱过你</p>\n<p>你是我最美的回忆</p>\n<p>点点滴滴那些甜蜜抹不去</p>\n<p>全都是你的回忆</p>\n<p>你看那 看那  片天空</p>\n<p>依旧像昨天的蔚蓝</p>\n<p>你听那  听那  一阵风</p>\n<p>风里全都是我的思念</p>\n<p>不曾后悔爱过你</p>\n<p>你是我最美的回忆</p>\n<p>点点滴滴  那些甜蜜抹不去</p>\n<p>全都是你的回忆</p>\n<p>你看那  看那  片天空</p>\n<p>依旧像昨天的蔚蓝</p>\n<p>你听那  听那  一阵风</p>\n<p>风里全都是我的思念</p>\n<p>我是天空里的云</p>\n<p>投影在你的城</p>\n<p>你是否看得见</p>\n<p>那阵细雨有我的泪</p>\n<p>我放任在天空飞</p>\n<p>随风飘舞任风吹</p>\n<p>你是否还在那座城里</p>\n<p>坚守着我的归期 坚守着我的归期</p>\n</center>","categories":[],"tags":["小欢喜"]},{"title":"关于在 Koa 中全局注入反作弊的思考","url":"http://jocolorful.com/2020/05/26/Koa全局注入反作弊/","content":"<p>我查阅过的资料</p>\n<p><a href=\"https://juejin.im/post/5ece2a1e6fb9a048021466b0?utm_source=gold_browser_extension\" target=\"_blank\" rel=\"noopener\">一杯茶的时间，上手 Koa2 + MySQL 开发</a></p>\n<p>前言：我们的项目是借助 Wepack，配置两套打包的脚本，分别输出服务端渲染「SSR」以及客户端渲染「CSR」所需要的资源。服务端渲染是利用「Koa」 以及渲染引擎 「Mustache」输出首屏内容。</p>\n<p>以上</p>\n<p>反作弊的状态码由后端返回</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">const MEMBER_FROZEN_EXCEPTION_MAP &#x3D; &#123;<br>  40350: &#39;abuseip&#39;,<br>  40351: &#39;imfrozen&#39;,<br>  40352: &#39;unhuman&#39;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>http status 状态码为 403 时需要进行异常处理。</p>\n<p>Node 端和 Client 端本身就是隔离的（所以有了同构技术），需要考虑在不同环境对<code>http status</code>的处理。</p>\n<p>我可以联想到以下关键字👇</p>\n<p>「中间件」「责任链模式」「洋葱模型」「你是否真的懂 try…catch」</p>\n<h1 id=\"中间件\"><a href=\"#中间件\" class=\"headerlink\" title=\"中间件\"></a>中间件</h1><blockquote>\n<p>为什么叫中间件？因为出于 Http 的 Request 和 Response 中间，用来实现某种功能。</p>\n</blockquote>\n<p>我的老板提出这个问题时，我几乎立刻抖了个机灵：写个中间件呗？（因为我室友就是专业写中间件的，hahaha）</p>\n<p>老板：嗯？Koa 基于洋葱模型，那能拿到 http 状态吗？</p>\n<p>抖机灵：从 ctx 取呗？</p>\n<p>老板：那 C 端怎么做呢？</p>\n<p>抖机灵：从 fetch 请求直接 reject 出来！</p>\n<img src=\"/images/koa.png\"  width=\"500px\" />\n\n<p>哦! Koa 对标 Express 底层 <a href=\"https://github.com/senchalabs/connect\" target=\"_blank\" rel=\"noopener\">connect</a></p>\n<img src=\"/images/onion.png\"  width=\"500px\" />\n\n<p>嘿嘿嘿，虽然把网上这个图抄过来了。但是我们可以仔细看看这个中间件的设计！什么设计？顺序！</p>\n<p>目前我们的 xen 项目已经有了各类错误上抛的机制，我在想在 中间件 的基础上是否能在加入</p>\n<ol>\n<li>缓存控制的中间件</li>\n</ol>\n<p>还没想好，想好在补吧</p>\n","categories":[],"tags":["不知不会"]},{"title":"CSS 加载会造成阻塞吗？","url":"http://jocolorful.com/2020/05/25/我需要背会的前端知识体系/","content":"<p><a href=\"https://github.com/Nealyang/PersonalBlog/issues/48\" target=\"_blank\" rel=\"noopener\">原文链接</a></p>\n<h1 id=\"👉-CSS-加载会造成阻塞吗\"><a href=\"#👉-CSS-加载会造成阻塞吗\" class=\"headerlink\" title=\"👉 CSS 加载会造成阻塞吗\"></a><a href=\"https://juejin.im/post/5b88ddca6fb9a019c7717096\" target=\"_blank\" rel=\"noopener\">👉 CSS 加载会造成阻塞吗</a></h1><p>读后感：</p>\n<p>在浏览器引擎渲染的世界里，我简单地将 HTML 呈现给用户的方式分为了两个过程：加载以及渲染。</p>\n<p>DOM 树从上至下依次<strike>渲染</strike> 解析。遇到 script 标签时，默认会阻止页面解析并平行下载 JS 文件。所以大部分的文章建议你将 JS 文件放在 body 后面，这样不会影响 HTML 的解析。</p>\n<p>属性<code>defer</code>以及<code>async</code>不会阻塞页面解析，文档解析完成之后，<code>defer</code> 和 <code>async</code> 脚本执行。<code>defer</code>以及<code>async</code> 的区别在于：<code>defer</code>执行脚本的顺序是加载顺序 而<code>async</code>则不能保证顺序。同时这两个属性都只在外链时生效，即含有<code>src</code>属性时生效。</p>\n<p>在看完文章之后，我再次</p>\n<h1 id=\"提问？\"><a href=\"#提问？\" class=\"headerlink\" title=\"提问？\"></a>提问？</h1><p>既然问题是 CSS 是否会造成阻塞，那么阻塞什么内容呢？</p>\n<p>DOM 的解析？DOM 的渲染？JS 的加载？JS的执行？</p>\n<h1 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h1><p>以上我们可以分析出：</p>\n<ol>\n<li><p>CSS 的加载并不会阻塞 DOM 的解析</p>\n</li>\n<li><p>CSS 的加载会阻塞 DOM 的渲染</p>\n</li>\n<li><p>CSS 的加载不会阻塞 JS 的加载，JS 加载阻塞和 script 标签的位置以及是否含有 <code>defer</code> 和 <code>async</code> 属性相关</p>\n</li>\n<li><p>CSS 的加载会阻塞「后面 JS」语句的执行，（DOMContentLoaded 内容解析完成）因为 JS 有可能需要操作前面 DOM 的样式。其他其他情况下，DOMContentLoaded 都不会等待 CSS 加载，并且 DOMContentLoaded 事件也不会等待图片、视频等其他资源加载。</p>\n</li>\n</ol>\n","categories":[],"tags":["CSS 我需要背会的前端知识体系"]},{"title":"实用 Demo 整理","url":"http://jocolorful.com/2020/05/23/实用Demo整理/","content":"<p><a href=\"https://codesandbox.io/s/sortabletree-pwrfv\" target=\"_blank\" rel=\"noopener\">👉 使用 react-dnd 实现拖拽 </a><br><a href=\"https://codesandbox.io/s/draft-js-highlight-ir4bd\" target=\"_blank\" rel=\"noopener\">👉  使用 draft.js 实现编辑器文本高亮</a></p>\n","categories":[],"tags":["整理"]},{"title":"搬砖公主折腾记","url":"http://jocolorful.com/2020/05/11/搬砖公主折腾记/","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>这也不知道是我第几次折腾博客了，希望是最后一次！<br>我的博客是基于 Hexo 的静态页面生成<br>在不断折腾博客的时候，我总结了几个坑👇</p>\n<ol>\n<li>源文件经常丢失。</li>\n<li>图片存储在七牛云，强依赖第三方过了几年有些图片已经不能正常显示。🤦‍♀️</li>\n<li>能动性不强，一年也就更个两三篇。</li>\n<li>主题常常跑偏…</li>\n</ol>\n<h1 id=\"回归之路\"><a href=\"#回归之路\" class=\"headerlink\" title=\"回归之路\"></a>回归之路</h1><blockquote>\n<p>给自己提问：为什么要重新记录这个博客？我是否能够坚持？</p>\n</blockquote>\n<p>记录这个博客的原因很简单：</p>\n<ol>\n<li><p>换电脑需要配置一些环境时，我希望能够有一份完善的配置记录，我能够无脑 copy 配置。</p>\n</li>\n<li><p>作为一名前端开发，我希望能够有技术沉淀。将近三年的开发经验让我养成了「问为什么」的习惯。我希望我弄能掌握每个知识点。当然我的我的脸皮足够厚，即便到了第三个工作的年头，我依旧承认有些 HTML 的属性我并不是完全掌握。</p>\n</li>\n<li><p>我能够坚持吗？hhhh，我自己都持怀疑态度，也许有人监督会好一些吧。但是我希望每一篇文章都足够高质量并且用心，有时候并不是为了产出而产出。可能会记更多 bug 以及思考之类的？</p>\n</li>\n</ol>\n<p>暂时只想到这些吧，源文件的丢失导致我得重新生成把以前的博客整理一下</p>\n<p>当然，我希望我的博客不仅仅只有技术，这里也融入了我对生活的态度。</p>\n","categories":[],"tags":[]},{"title":"about","url":"http://jocolorful.com/2020/05/11/about/","content":"","categories":[],"tags":[]},{"title":"iTerm2","url":"http://jocolorful.com/2020/05/11/2/","content":"<p>iTerm2 是我常用的终端工具，每次换电脑安装的第一个软件就是它。青睐于 iTerm 的原因很简单：</p>\n<ol>\n<li>支持分屏模式</li>\n<li>可配置插件</li>\n<li>颜值 online</li>\n</ol>\n<p>I love this black cat background！</p>\n<img src=\"/images/iterm.png\"  width=\"500px\"/>\n\n<h1 id=\"Shell-冷知识\"><a href=\"#Shell-冷知识\" class=\"headerlink\" title=\"Shell 冷知识\"></a>Shell 冷知识</h1><p>前端开发往往不关心 *nix 内核。Shell 仅仅只是一个「壳」而已。我们借助 Shell 和内核打交道。Mac 自带终端的 Shell 是 bash。常见的 Shell 有 sh、bash、zsh、csh</p>\n<p>通过</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">cat &#x2F;etc&#x2F;shells<br></code></pre></td></tr></table></figure>\n\n<p>可以查看安装<br><img src=\"/images/cat.png\"  width=\"300px\"/></p>\n<h1 id=\"zsh\"><a href=\"#zsh\" class=\"headerlink\" title=\"zsh\"></a>zsh</h1><h2 id=\"手动安装\"><a href=\"#手动安装\" class=\"headerlink\" title=\"手动安装\"></a>手动安装</h2><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">git <span class=\"hljs-built_in\">clone</span> git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh<br>cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc<br>chsh -s /bin/zsh<br></code></pre></td></tr></table></figure>\n\n<p>换回bash</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">chsh -s /bin/bash<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"自动安装\"><a href=\"#自动安装\" class=\"headerlink\" title=\"自动安装\"></a>自动安装</h2><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h1><h2 id=\"必备插件\"><a href=\"#必备插件\" class=\"headerlink\" title=\"必备插件\"></a>必备插件</h2><p><a href=\"https://github.com/ohmyzsh/ohmyzsh\" target=\"_blank\" rel=\"noopener\">ohmyzsh</a><br>itermpreference.png</p>\n<p>内置了 git 的插件管理 还有一些漂亮的主题，这里不在赘述</p>\n<h2 id=\"快捷键\"><a href=\"#快捷键\" class=\"headerlink\" title=\"快捷键\"></a>快捷键</h2><p>对于日常开发我常用分屏模式，已经能够满足对于多个窗口的诉求</p>\n<p>command + D<br>command + shift + D</p>\n<h3 id=\"默认打开工作区\"><a href=\"#默认打开工作区\" class=\"headerlink\" title=\"默认打开工作区\"></a>默认打开工作区</h3><p>在 preference 的设置里面，我勾选了 Reuse previous session‘s directory。</p>\n<img src=\"/images/itermpreference.png\"  width=\"300px\"/>\n\n<p>这样每次打开都是从上一个工作区切出来的目录，这对于一个项目需要启动多个端口来说非常友好。</p>\n<h3 id=\"open-Buff\"><a href=\"#open-Buff\" class=\"headerlink\" title=\"open Buff\"></a>open Buff</h3><p>其实这算事 iTerm 的一个 Buff，我给 ~/.zshrc 配置了 open 命令的别名：</p>\n<img src=\"/images/itermalias.png\"  width=\"300px\"/>\n\n<p>这使得我可以使用终端快速打开文件。据我所知 atom 自带了 atom 命令来实现这个效果，但是我更倾向于自己 DIY，而不是依赖 IDE。这也是我选择 sublime 的原因。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">subl &#123;path&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"颜值-Buff\"><a href=\"#颜值-Buff\" class=\"headerlink\" title=\"颜值 Buff\"></a>颜值 Buff</h3><p>做为一只颜狗，我给 iTerm2 配置了背景图，并且设置了默认的行列数，以减少手动放大 iTerm2。</p>\n<img src=\"/images/itermbg.png\"  width=\"300px\"/>\n","categories":[],"tags":[]},{"title":"","url":"http://jocolorful.com/css/personal-style.css","content":".page-post body {\n \tposition: relative;\n  min-height: 100vh;\n  background-image: linear-gradient(to top right, rgba(0,132,255, 0.9) 50%, rgba(0,132,255,.1) 50%);\n  background-size: 100% calc(100% - 100vh + 5px);\n  z-index: 1;\n}\n\n.page-post body::after {\n  content: \"\";\n  position: fixed;\n  top: 5px;\n  left: 0;\n  bottom: 0;\n  right: 0;\n  background: #fff;\n  z-index: -1;\n}\n\n.article-content a {\n  color: rgba(0,132,255, 0.9);\n}\n\na:hover {\n\tcolor: rgba(0,132,255, 0.9) !important;\n}\n\n.highlight .html, .gutter{\n  display: none\n}\n\n.highlight {\n  background: black;\n}\n\n.pagination .next,\n.pagination .prev {\n  display: none !important;\n}\n\ncode,\nfigure.highlight {\n  padding-top: 40px;\n  background: rgb(39, 40, 34) !important;\n  color: rgb(248, 248, 242) !important;\n  position: relative;\n}\ncode {\n  padding: 0;\n  position: relative;\n}\n\n.highlight::after {\n  top: 12px;\n  width: 12px;\n  height: 12px;\n  border-radius: 50%;\n  position: absolute;\n  background: rgb(255, 95, 86);\n  content: '';\n}\n\n.highlight::before {\n  top: 12px;\n  left: 40px;\n  width: 12px;\n  height: 12px;\n  border-radius: 50%;\n  position: absolute;\n  background: rgb(255, 189, 46);\n  content: '';\n}","categories":[],"tags":[]},{"title":"link","url":"http://jocolorful.com/link/index.html","content":"","categories":[],"tags":[]},{"title":"tag","url":"http://jocolorful.com/tag/index.html","content":"","categories":[],"tags":[]},{"title":"search","url":"http://jocolorful.com/search/index.html","content":"","categories":[],"tags":[]}]